<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>フェーズ付き弾幕ゲーム</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
      color: white;
      text-align: center;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: #111;
    }
    #startButton, #retryButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 12px 24px;
      font-size: 20px;
      background-color: #444;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    #retryButton {
      display: none;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="600" height="600"></canvas>
<button id="startButton">ゲーム開始</button>
<button id="retryButton">もう一度</button>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const startButton = document.getElementById("startButton");
  const retryButton = document.getElementById("retryButton");

  let keys = {};
  let bullets = [];
  let beams = [];
  let frame = 0;
  let phase = 1;
  let phaseTimer = 0;
  let gameRunning = false;

  let player, enemy;

  function initGame() {
    bullets = [];
    beams = [];
    frame = 0;
    phase = 1;
    phaseTimer = 0;
    gameRunning = true;

    player = {
      x: 300,
      y: 500,
      radius: 5,
      speed: 3,
      color: "lime",
      life: 3,
      alive: true
    };

    enemy = {
      x: 300,
      y: 150,
      vx: 1.5,
      vy: 1.5,
      radius: 12,
      color: "orange"
    };
  }

  document.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
  document.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

  function movePlayer() {
    if (!player.alive) return;
    if (keys["w"] && player.y > 0) player.y -= player.speed;
    if (keys["s"] && player.y < canvas.height) player.y += player.speed;
    if (keys["a"] && player.x > 0) player.x -= player.speed;
    if (keys["d"] && player.x < canvas.width) player.x += player.speed;
  }

  function moveEnemy() {
    enemy.x += enemy.vx;
    enemy.y += enemy.vy;

    if (Math.random() < 0.02) enemy.vx = (Math.random() - 0.5) * 4;
    if (Math.random() < 0.02) enemy.vy = (Math.random() - 0.5) * 4;

    if (enemy.x < 0 || enemy.x > canvas.width) enemy.vx *= -1;
    if (enemy.y < 0 || enemy.y > canvas.height) enemy.vy *= -1;
  }

  function createBullet(angle, speed, radius = 4, color = "red", deadly = false) {
    return {
      x: enemy.x,
      y: enemy.y,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed,
      radius,
      color,
      deadly
    };
  }

  function firePhase1() {
    if (frame % 60 !== 0) return;
    const count = 12;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 / count) * i;
      bullets.push(createBullet(angle, 1.2));
    }
  }

  function firePhase2() {
    if (frame % 30 !== 0) return;
    const count = 6;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 0.5 + Math.random() * 2;
      bullets.push(createBullet(angle, speed, Math.random() * 3 + 2, "yellow"));
    }
  }

  let beamAngle = 0;
  
  function firePhase3() {
    beams = []; // 毎フレーム更新なので前のをクリア
  
    const directions = 4; // 十字（上下左右）
    for (let i = 0; i < directions; i++) {
      const angle = beamAngle + (Math.PI / 2) * i;
      beams.push({
        angle,
        radius: 8,
        color: "cyan",
        timer: 2 // 毎フレーム再生成するので短めでOK
      });
    }
  
    beamAngle += 0.02; // 回転スピード調整
  }

  // ビームの描画を変更（updateは移動させない）
  function updateBeams() {
    // 今回は動かないビームなので更新処理なしでOK
    }
  function drawRotatingBeams() {
    beams.forEach(beam => {
      const angle = beam.angle;
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
  
      // 始点・終点をキャンバス端まで
      const startX = enemy.x - dx * 1000; // 画面外まで伸ばす感じ
      const startY = enemy.y - dy * 1000;
      const endX = enemy.x + dx * 1000;
      const endY = enemy.y + dy * 1000;
  
      ctx.strokeStyle = beam.color;
      ctx.lineWidth = beam.radius;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.stroke();
    });
  }
  
  
    function firePhase4() {
      if (frame % 90 !== 0) return;
      const speed = 6;
      const size = 12;
      const directions = [
        { x: canvas.width / 2, y: 0, dx: 0, dy: speed },
        { x: canvas.width / 2, y: canvas.height, dx: 0, dy: -speed },
        { x: 0, y: canvas.height / 2, dx: speed, dy: 0 },
        { x: canvas.width, y: canvas.height / 2, dx: -speed, dy: 0 }
      ];
      directions.forEach(dir => {
        beams.push({ ...dir, radius: size, color: "cyan", timer: 60 });
      });
    }
  
  function firePhase5() {
    if (frame % 120 !== 0) return;
    const count = 8;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 / count) * i;
      bullets.push(createBullet(angle, 6, 6, "magenta", true));
    }
  }

  function updateBullets() {
    bullets.forEach(b => {
      b.x += b.dx;
      b.y += b.dy;
    });
  }

  function updateBeams() {
    for (let i = beams.length - 1; i >= 0; i--) {
      const b = beams[i];
      b.x += b.dx;
      b.y += b.dy;
      b.timer--;
      if (b.timer <= 0) beams.splice(i, 1);
    }
  }

  function drawCircle(obj) {
    ctx.beginPath();
    ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
    ctx.fillStyle = obj.color;
    ctx.fill();
  }

  function checkCollision() {
    if (!player.alive) return;

    for (const b of bullets) {
      const dx = b.x - player.x;
      const dy = b.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < b.radius + player.radius) {
        if (b.deadly || phase === 5) {
          player.life = 0;
          player.alive = false;
        } else {
          player.life--;
          if (player.life <= 0) player.alive = false;
        }
        bullets.splice(bullets.indexOf(b), 1);
        break;
      }
    }

    for (const beam of beams) {
      const dx = beam.x - player.x;
      const dy = beam.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < beam.radius + player.radius) {
        player.life = 0;
        player.alive = false;
      }
    }
  }

  function drawUI() {
    ctx.fillStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.fillText(`LIFE: ${player.life}`, 20, 30);
    ctx.fillText(`PHASE: ${phase}`, 20, 50);
  }

  function drawGameOver() {
    ctx.fillStyle = "white";
    ctx.font = "48px sans-serif";
    ctx.fillText("GAME OVER", canvas.width / 2 - 140, canvas.height / 2);
    retryButton.style.display = "block";
  }

  function updatePhase() {
    phaseTimer++;
    if (phaseTimer === 600) phase = 2;
    else if (phaseTimer === 1200) phase = 3;
    else if (phaseTimer === 1800) phase = 4;
    else if (phaseTimer === 2400) phase = 5;
  }

  function gameLoop() {
    if (!gameRunning) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!player.alive) {
      drawGameOver();
      return;
    }

    movePlayer();
    moveEnemy();
    updatePhase();

    // 発射処理
    switch (phase) {
      case 1: firePhase1(); break;
      case 2: firePhase2(); break;
      case 3: firePhase3(); break;
      case 4: firePhase4(); break;
      case 5: firePhase5(); break;
    }

    updateBullets();
    updateBeams();
    checkCollision();

    bullets.forEach(drawCircle);
    beams.forEach(drawCircle);
    drawCircle(player);
    drawCircle(enemy);
    drawUI();

    frame++;
    requestAnimationFrame(gameLoop);
  }

  startButton.onclick = () => {
    startButton.style.display = "none";
    initGame();
    gameLoop();
  };

  retryButton.onclick = () => {
    retryButton.style.display = "none";
    initGame();
    gameLoop();
  };
</script>
</body>
</html>

