<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç”Ÿãæ®‹ã‚Œï¼ã‚¿ã‚¤ãƒ”ãƒ³ã‚°é­”è¡“ã®æ£®</title>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,"Segoe UI","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;background:#0b1020;color:#eaf0ff}
    .wrap{max-width:980px;margin:0 auto;padding:18px}
    .card{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);border-radius:14px;padding:14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:#eaf0ff;padding:10px 12px;border-radius:12px}
    input{padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.18);background:rgba(0,0,0,.25);color:#eaf0ff;outline:none}
    .chip{border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);border-radius:999px;padding:8px 10px;font-size:13px}
    .hud{display:flex;gap:10px;flex-wrap:wrap}
    .prompt{font-size:20px;line-height:1.7;word-break:break-word}
    .done{color:#35d07f}
    .next{text-decoration:underline;text-decoration-color:#7c5cff;text-underline-offset:3px}
    .todo{opacity:.92}
    .small{font-size:12px;opacity:.8;line-height:1.6}
    canvas{width:100%;height:320px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.10);margin-top:10px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>ğŸ’€ ç”Ÿãæ®‹ã‚Œï¼ã‚¿ã‚¤ãƒ”ãƒ³ã‚°é­”è¡“ã®æ£®</h1>

  <div class="card">
    <div class="row">
      <label>åå‰ <input id="name" placeholder="ä¾‹ï¼škoppy" maxlength="16"></label>
      <button class="btn" id="btnStart">é–‹å§‹</button>
      <button class="btn" id="btnStop">åœæ­¢</button>
    </div>
    <div class="hud" style="margin-top:10px">
      <span class="chip">â¤ï¸ <span id="hp">3</span></span>
      <span class="chip">ğŸ’€ <span id="kills">0</span></span>
      <span class="chip">âš¡ <span id="wpm">0</span></span>
      <span class="chip">ğŸ¯ <span id="acc">100.0</span>%</span>
      <span class="chip">â±ï¸ <span id="t">0.0</span>s</span>
    </div>
    <div class="small" style="margin-top:10px">
      æ•µã¯ğŸ’€å›ºå®šã€‚æœ€ã‚‚è¿‘ã„ğŸ’€ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§ã™ã€‚æ‰“ã¡åˆ‡ã‚‹ã¨æ’ƒç ´ã€‚æ¥è§¦ã•ã‚Œã‚‹ã¨HPæ¸›å°‘ã€‚
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <div class="prompt" id="prompt"></div>
    <div class="row" style="margin-top:10px">
      <input id="inp" placeholder="ã“ã“ã«å…¥åŠ›ï¼ˆ1æ–‡å­—ãšã¤åˆ¤å®šï¼‰" style="flex:1 1 340px">
    </div>
    <canvas id="cv" width="980" height="320"></canvas>
  </div>
</div>

<script type="module">
  const V = "11.0.0";
  import { initializeApp } from `https://www.gstatic.com/firebasejs/${V}/firebase-app.js`;
  import { getAuth, signInAnonymously } from `https://www.gstatic.com/firebasejs/${V}/firebase-auth.js`;
  import { getFirestore, doc, setDoc, serverTimestamp } from `https://www.gstatic.com/firebasejs/${V}/firebase-firestore.js`;

  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_PROJECT.firebaseapp.com",
    projectId: "YOUR_PROJECT_ID",
    appId: "YOUR_APP_ID",
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);
  const u = await signInAnonymously(auth);
  const uid = u.user.uid;

  const ui = {
    name: document.getElementById("name"),
    btnStart: document.getElementById("btnStart"),
    btnStop: document.getElementById("btnStop"),
    hp: document.getElementById("hp"),
    kills: document.getElementById("kills"),
    wpm: document.getElementById("wpm"),
    acc: document.getElementById("acc"),
    t: document.getElementById("t"),
    prompt: document.getElementById("prompt"),
    inp: document.getElementById("inp"),
    cv: document.getElementById("cv"),
  };
  const ctx = ui.cv.getContext("2d");

  const WORDS = ["ã¾ã»ã†","ã‚‚ã‚Š","ã©ã","ãã‚Š","sprint","focus","typing","shadow","skull","danger","escape","combo"];
  function pickWord(){
    // é›£åº¦ã‚’ä¸Šã’ãŸã„ãªã‚‰é•·ã•ã‚’æ™‚é–“ã§å¢—ã‚„ã™ï¼ˆã“ã“ã¯ç°¡æ˜“ï¼‰
    return WORDS[Math.floor(Math.random()*WORDS.length)];
  }
  function esc(s){return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");}

  const state = {
    running:false,
    startMs:0,
    hp:3,
    kills:0,
    total:0, correct:0,
    // enemies: { id, text, i, dist(0..1) } dist=1é ã„â†’0æ¥è§¦
    enemies:[],
    spawnEveryMs: 1500,
    lastSpawnMs:0,
    loop:null,
  };
  let nextId = 1;

  function renderPrompt(){
    const target = getTarget();
    if(!target){ ui.prompt.textContent = "é–‹å§‹ã™ã‚‹ã¨ğŸ’€ãŒç¾ã‚Œã¾ã™"; return; }
    const t = target.text;
    const i = target.i;
    const done = t.slice(0,i), next = t[i]??"", todo = t.slice(i+1);
    ui.prompt.innerHTML = `<span class="done">${esc(done)}</span>${next?`<span class="next">${esc(next)}</span>`:""}<span class="todo">${esc(todo)}</span>`;
  }
  function getTarget(){
    // æœ€ã‚‚è¿‘ã„æ•µï¼ˆdistãŒå°ã•ã„ï¼‰
    return state.enemies.slice().sort((a,b)=>a.dist-b.dist)[0] ?? null;
  }
  function metrics(){
    const elapsed = Math.max(1, performance.now()-state.startMs);
    const min = elapsed/60000;
    const wpm = (state.correct/5)/min;
    const acc = state.total ? (state.correct/state.total)*100 : 100;
    return { elapsed, wpm, acc };
  }

  function spawn(){
    state.enemies.push({ id: nextId++, text: pickWord(), i: 0, dist: 1.0 });
  }

  function tick(){
    if(!state.running) return;
    const now = performance.now();
    const elapsedSec = (now - state.startMs)/1000;

    // é›£æ˜“åº¦ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆã‚†ã‚‹ãï¼‰
    const speed = 0.12 + Math.min(0.18, elapsedSec * 0.002); // è¿«ã‚‹é€Ÿåº¦
    state.spawnEveryMs = Math.max(650, 1500 - elapsedSec*8);

    // spawn
    if(now - state.lastSpawnMs >= state.spawnEveryMs){
      state.lastSpawnMs = now;
      spawn();
    }

    // move enemies
    for(const e of state.enemies){
      e.dist -= speed * 0.016; // 60fpsæƒ³å®š
    }

    // contact
    const hit = state.enemies.filter(e=>e.dist <= 0);
    if(hit.length){
      state.hp -= hit.length;
      state.enemies = state.enemies.filter(e=>e.dist > 0);
      if(state.hp <= 0){
        state.hp = 0;
        stop(true);
        return;
      }
    }

    // hud
    const { elapsed, wpm, acc } = metrics();
    ui.hp.textContent = String(state.hp);
    ui.kills.textContent = String(state.kills);
    ui.wpm.textContent = String(Math.round(wpm));
    ui.acc.textContent = acc.toFixed(1);
    ui.t.textContent = (elapsed/1000).toFixed(1);

    renderPrompt();
    draw();
    requestAnimationFrame(tick);
  }

  function draw(){
    const W = ui.cv.width, H = ui.cv.height;
    ctx.clearRect(0,0,W,H);

    // background fog lines
    ctx.globalAlpha = 0.25;
    for(let i=0;i<12;i++){
      ctx.fillStyle = "#ffffff";
      ctx.fillRect((i*97 + (performance.now()/20)%97)%W, 40+i*18, 60, 2);
    }
    ctx.globalAlpha = 1;

    // ground
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#000";
    ctx.fillRect(0,H-60,W,60);
    ctx.globalAlpha = 1;

    // enemies
    const sorted = state.enemies.slice().sort((a,b)=>b.dist-a.dist); // é â†’è¿‘
    for(const e of sorted){
      const x = 60 + (1-e.dist) * (W-120);
      const y = H/2 - 30;
      const size = 26 + (1-e.dist)*22;
      ctx.font = `${size}px system-ui`;
      ctx.fillText("ğŸ’€", x, y);

      // label
      ctx.font = `14px ui-monospace, monospace`;
      ctx.globalAlpha = 0.9;
      ctx.fillText(e.text.slice(e.i), x, y+26);
      ctx.globalAlpha = 1;
    }

    // player
    ctx.font = `26px system-ui`;
    ctx.fillText("ğŸ§™", 20, H/2-30);
  }

  function start(){
    state.running = true;
    state.startMs = performance.now();
    state.hp = 3;
    state.kills = 0;
    state.total = 0;
    state.correct = 0;
    state.enemies = [];
    state.lastSpawnMs = 0;
    ui.inp.value = "";
    ui.inp.focus();
    spawn();
    requestAnimationFrame(tick);
  }

  async function stop(gameOver){
    state.running = false;
    const { wpm, acc } = metrics();
    // Save: forest => score=kills
    await saveScore("forest", { wpm, acc, score: state.kills });
    alert(gameOver ? `ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ğŸ’€æ’ƒç ´ ${state.kills} ä½“` : "åœæ­¢ã—ã¾ã—ãŸï¼ˆè¨˜éŒ²ä¿å­˜ï¼‰");
  }

  async function saveScore(mode, { wpm, acc, score }){
    const name = (ui.name.value || "Guest").trim().slice(0,16) || "Guest";
    const ref = doc(db, "leaderboards", mode, "scores", uid);
    await setDoc(ref, { name, wpm, acc, score, updatedAt: serverTimestamp() }, { merge:true });
  }

  ui.inp.addEventListener("keydown", (e)=>{
    if(!state.running) return;
    if(e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey){
      e.preventDefault();
      const target = getTarget();
      if(!target) return;
      const expected = target.text[target.i];
      state.total++;
      if(e.key === expected){
        state.correct++;
        target.i++;
        if(target.i >= target.text.length){
          // kill
          state.kills++;
          state.enemies = state.enemies.filter(x=>x.id !== target.id);
        }
      } else {
        // ãƒŸã‚¹ã—ã¦ã‚‚é€²ã‚ãªã„ï¼ˆé€Ÿåº¦ç³»ãªã®ã§è»½ãƒšãƒŠç„¡ã—ï¼‰
      }
    }
  });

  ui.btnStart.addEventListener("click", start);
  ui.btnStop.addEventListener("click", ()=> stop(false));

  ui.prompt.textContent = "ã€Œé–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚";
</script>
</body>
</html>
